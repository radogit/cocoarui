{"mappings":"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","sources":["script.js"],"sourcesContent":["const width = 800, height = 600;\nconst collisionMargin = 10; // Extra space between nodes\n\nconst nodes = [\n    {\n        id: \"A\", x: 550, y: 550, color: 'green', radius: 30, areaRadius: 100, isFixed: false, significance: 100, hotspots: [\n            { x: 450, y: 150, intensityFactor: 1.5, width: 200, height: 300, forceType: \"attract\" },\n            { x: 600, y: 100, intensityFactor: 1.2, width: 120, height: 320, forceType: \"attract\"  },\n            { x: 700, y: 280, intensityFactor: 1.2, width: 320, height: 120, forceType: \"attract\"  }\n        ]\n    },\n    {\n        id: \"B\", x: 300, y: 300, color: 'blue', radius: 40, areaRadius: 150, isFixed: false, significance: 1, hotspots: [\n            { x: 200, y: 100, intensityFactor: 1.2, width: 180, height: 80, forceType: \"attract\"  },\n            { x: 250, y: 550, intensityFactor: 1.0, width: 180, height: 80, forceType: \"attract\"  }\n        ]\n    },\n    {\n        id: \"C\", x: 400, y: 400, color: 'orange', radius: 50, areaRadius: 150, isFixed: false, significance: 100, hotspots: [\n            { x: 210, y: 90, intensityFactor: 1.2, width: 180, height: 80, forceType: \"attract\"  },\n            { x: 260, y: 560, intensityFactor: 1.0, width: 180, height: 80, forceType: \"attract\"  }\n        ]\n    },\n    {\n        id: \"D\", x: 590, y: 180, color: 'purple', radius: 50, areaRadius: 150, isFixed: true, significance: 1, hotspots: []\n    }\n];\n\n// Ensure that nodes that start as fixed remain fixed\nnodes.forEach(d => {\n    if (d.isFixed) {\n        d.fx = d.x;\n        d.fy = d.y;\n    }\n});\n\nconst svg = d3.select(\"body\")\n    .append(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height);\n\nconst simulation = d3.forceSimulation(nodes)\n    .force(\"repel\", d3.forceManyBody().strength(d => d.isFixed ? 0 : -50)) // Mild repulsion\n    .force(\"collide\", d3.forceCollide().radius(d => d.radius + collisionMargin).strength(1.2)) // Prevent overlap\n    .force(\"gaussian\", forceGaussianPreferredArea(1.5)) // Gaussian force for hotspots\n    .force(\"customCollision\", forceCustomCollision) // New collision force!\n    .on(\"tick\", ticked);\n\n// Define gradients for each node's hotspots dynamically\nconst defs = svg.append(\"defs\");\n\nnodes.forEach(node => {\n    // Create a unique radial gradient for each node's hotspots\n    const gradient = defs.append(\"radialGradient\")\n        .attr(\"id\", `forceGradient-${node.id}`)\n        .attr(\"cx\", \"50%\")\n        .attr(\"cy\", \"50%\")\n        .attr(\"r\", \"50%\");\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"0%\")\n        .style(\"stop-color\", node.color)  // Use node's color for the center\n        .style(\"stop-opacity\", 0.4);\n\n    gradient.append(\"stop\")\n        .attr(\"offset\", \"100%\")\n        .style(\"stop-color\", \"white\")\n        .style(\"stop-opacity\", 0);\n});\n\n// Create hotspot rectangles for each node\nconst hotspotGroups = svg.selectAll(\".hotspot-group\")\n    .data(nodes)\n    .enter()\n    .append(\"g\")\n    .attr(\"class\", \"hotspot-group\");\n\n// Create each hotspot rectangle for a node\nhotspotGroups.selectAll(\".hotspot\")\n    .data(d => d.hotspots)\n    .enter()\n    .append(\"rect\")\n    .attr(\"class\", \"hotspot\")\n    .attr(\"x\", d => d.x - d.width / 2)\n    .attr(\"y\", d => d.y - d.height / 2)\n    .attr(\"width\", d => d.width)\n    .attr(\"height\", d => d.height)\n    .each(function(d) {\n        // Ensure each hotspot references the correct node ID dynamically\n        d.nodeId = d3.select(this.parentNode).datum().id;\n        d.color = d3.select(this.parentNode).datum().color;\n    })\n    .style(\"fill\", d => `url(#forceGradient-${d.nodeId})`)  // Correctly associate hotspot with node's gradient\n    .style(\"stroke\", d=>d.color)        // Thin black border\n    .style(\"stroke-width\", 1)        // Border thickness\n    .style(\"stroke-dasharray\", \"4,2\") // Dashed border (4px dash, 2px space)    \n    .style(\"opacity\", 0.9)\n;\n\n// Create a group for each node\nconst nodeGroup = svg.selectAll(\".node-group\")\n    .data(nodes)\n    .enter()\n    .append(\"g\")\n    .attr(\"class\", \"node-group\")\n    .attr(\"transform\", d => `translate(${d.x}, ${d.y})`) // Positioning\n    .on(\"dblclick\", toggleFixed) // to toggle fixed state\n    .call(d3.drag()\n        .on(\"start\", dragStart)\n        .on(\"drag\", dragging)\n        .on(\"end\", dragEnd)\n    );\n\n// Append circles inside the group (node circles)\nnodeGroup.append(\"circle\")\n    .attr(\"fill\", d => d.color)  // Node color\n    .attr(\"opacity\", 0.6)\n    .attr(\"r\", d => d.radius)\n    .attr(\"stroke\", d => d.isFixed ? \"black\" : \"none\") // Visual cue: Black stroke if fixed\n    .attr(\"stroke-width\", d => d.isFixed ? 3 : 0)\n    ;\n\n// Append labels inside the group\nnodeGroup.append(\"text\")\n    .attr(\"dx\", 0)  // Offset to the right of the circle\n    .attr(\"dy\", d => -d.radius - 2)   // Slightly above center\n    .attr(\"text-anchor\", \"middle\")\n    .text(d => d.id)\n    .attr(\"font-size\", \"20px\")\n    .attr(\"fill\", \"black\")\n    .attr(\"opacity\", 0.5);\n\n// Append secondary text for coordinates\nnodeGroup.append(\"text\")\n    .attr(\"class\", \"coord-label\")\n    .attr(\"dx\", 0) //d => d.radius)  // to the right\n    .attr(\"dy\", d => d.radius + 15) // Below the node\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"font-size\", \"10px\")\n    .attr(\"fill\", \"black\")\n    .attr(\"opacity\", 0.5);\n\n// Create a new group for the force arrows that will be inside each node's group\nconst forceArrows = nodeGroup.append(\"g\")  // Add this line to ensure arrows are inside the node group\n    .attr(\"class\", \"force-arrows\");\n\n// Define arrowhead marker for better visualization\nsvg.append(\"defs\").append(\"marker\")\n    .attr(\"id\", \"arrowhead-white\")\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 5)\n    .attr(\"refY\", 5)\n    .attr(\"markerWidth\", 4)\n    .attr(\"markerHeight\", 4)\n    .attr(\"orient\", \"auto\")\n    .append(\"path\")\n    .attr(\"d\", \"M0,0 L10,5 L0,10 Z\")\n    .attr(\"fill\", \"white\")\n    ;\n    svg.append(\"defs\").append(\"marker\")\n    .attr(\"id\", \"arrowhead-orange\")\n    .attr(\"viewBox\", \"0 0 10 10\")\n    .attr(\"refX\", 5)\n    .attr(\"refY\", 5)\n    .attr(\"markerWidth\", 4)\n    .attr(\"markerHeight\", 4)\n    .attr(\"orient\", \"auto\")\n    .append(\"path\")\n    .attr(\"d\", \"M0,0 L10,5 L0,10 Z\")\n    .attr(\"fill\", \"orange\")\n    ;\n\nfunction ticked() {\n    nodeGroup.attr(\"transform\", d => `translate(${d.x}, ${d.y})`);\n    nodeGroup.select(\".coord-label\")\n    .text(d => `(${Math.round(d.x)}, ${Math.round(d.y)})`);\n    \n    // Update hotspot positions (for visualizing hotspot areas)\n    hotspotGroups.selectAll(\".hotspot\")\n        .attr(\"x\", d => d.x - d.width / 2)\n        .attr(\"y\", d => d.y - d.height / 2);\n\n    // Clear previous arrows before drawing new ones\n    forceArrows.selectAll(\".force-arrow\").remove();  \n\n    nodeGroup.select(\"circle\")\n        .attr(\"stroke\", d => d.isFixed ? \"black\" : \"none\")\n        .attr(\"stroke-width\", d => d.isFixed ? 3 : 0);\n\n    // // Enforce collision constraints AFTER forces are applied\n    // nodes.forEach((d, i) => {\n    //     nodes.forEach((other, j) => {\n    //         if (i !== j) {\n    //             const dx = d.x - other.x;\n    //             const dy = d.y - other.y;\n    //             const distance = Math.sqrt(dx * dx + dy * dy);\n    //             const minDist = d.radius + other.radius + collisionMargin; // Include margin\n\n    //             if (distance < minDist && distance > 0) {  \n    //                 // Nodes are too close → Push them apart immediately\n    //                 const overlap = minDist - distance;\n    //                 const pushX = (dx / distance) * overlap * 0.5; // Half push each node\n    //                 const pushY = (dy / distance) * overlap * 0.5;\n\n    //                 if (!d.isFixed) { d.x += pushX * 0.5; d.y += pushY * 0.5; }\n    //                 if (!other.isFixed) { other.x -= pushX; other.y -= pushY; }\n    //             }\n    //         }\n    //     });\n    // });\n\n    // Add arrows based on the calculated forces\n    nodeGroup.each(function(d) {\n        const arrowGroup = d3.select(this).select(\".force-arrows\");\n\n        // Draw individual force arrows (e.g., from hotspots)\n        d.forces.forEach(force => {\n            const length = Math.min(Math.sqrt(force.fx ** 2 + force.fy ** 2) * 0.5, 100);\n            const angle = Math.atan2(force.fy, force.fx);\n\n            arrowGroup.append(\"line\")\n                .attr(\"class\", \"force-arrow\")\n                .attr(\"x1\", 0)\n                .attr(\"y1\", 0)\n                .attr(\"x2\", length * Math.cos(angle))\n                .attr(\"y2\", length * Math.sin(angle))\n                //.attr(\"stroke\", \"white\")\n                .attr(\"stroke\", force.source.includes(\"collision\") ? \"orange\" : \"white\")\n                .attr(\"stroke-width\", 5)\n                .attr(\"marker-end\", \"url(#arrowhead-\"+(force.source.includes(\"collision\") ? \"orange\" : \"white\")+\")\")\n                .style(\"opacity\", 0.9);\n        });\n\n        // Draw net force arrow in **red**\n        const netForceX = d.vx;  // Total force from all sources\n        const netForceY = d.vy;\n        const netForceMagnitude = Math.sqrt(netForceX ** 2 + netForceY ** 2);\n\n        // Visual clarity: Net force should have a slightly transparent arrow\n        const netAlpha = netForceMagnitude > 0.9 ? 0.8 : 0.5;  \n\n        // Draw net force arrow (captures forces like collisions)\n        if (netForceMagnitude > 0.1) {  // Only draw if non-trivial\n            const netLength = Math.min(netForceMagnitude * 10, 100);\n            const netAngle = Math.atan2(netForceY, netForceX);\n\n            arrowGroup.append(\"line\")\n                .attr(\"class\", \"force-arrow net-force-arrow\")\n                .attr(\"x1\", 0)\n                .attr(\"y1\", 0)\n                .attr(\"x2\", netLength * Math.cos(netAngle))\n                .attr(\"y2\", netLength * Math.sin(netAngle))\n                .attr(\"stroke\", \"red\")  // Different color for net force\n                .attr(\"stroke-width\", 3)\n                .attr(\"marker-end\", \"url(#arrowhead)\")\n                .style(\"opacity\", netAlpha);\n        }\n    });\n}\n    \n\n// Custom force for Gaussian-like interaction between nodes and multiple hotspots\nfunction forceGaussianPreferredArea(strength) {\n    return function (alpha) {\n        nodes.forEach(d => {\n            d.forces = []; // Reset all force vectors\n\n            // Apply Hotspot Forces (Attract/Repel)\n            d.hotspots.forEach(hotspot => {\n                const dx = hotspot.x - d.x;\n                const dy = hotspot.y - d.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                if (distance > 1) {\n                    const force = Math.exp(-distance / hotspot.width) * strength * hotspot.intensityFactor;\n\n                    // Check the force type: attract vs. repel\n                    const fx = hotspot.forceType === \"attract\" ? dx * force : -dx * force;\n                    const fy = hotspot.forceType === \"attract\" ? dy * force : -dy * force;\n\n                    d.vx += fx * alpha;\n                    d.vy += fy * alpha;\n                    //d.forces.push({ fx: -dx * force, fy: -dy * force });\n                    d.forces.push({ fx, fy, source: \"hotspot\" });\n                }\n            });\n\n            nodes.forEach(other => {\n                if (d !== other) {\n                    const dx = other.x - d.x;\n                    const dy = other.y - d.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    const minDist = d.radius + other.radius + collisionMargin; // Include margin\n                    if(d.id==\"B\" && minDist>distance){console.log('distance of B to '+other.id+': '+distance + ' which is less than the midDist of' +minDist );}\n            \n                    if (distance < minDist) {\n                        const overlapRatio = 1 - distance / minDist; // How much they overlap (0 to 1)\n                        const force = (overlapRatio ** 2) * alpha * 5; // Quadratic falloff for smooth response\n            \n                        // Normalize direction and push nodes apart\n                        const pushX = (dx / distance) * (minDist - distance); \n                        const pushY = (dy / distance) * (minDist - distance);\n            \n                        d.vx -= pushX * alpha * 0.5; // Scale down to prevent excessive movement\n                        d.vy -= pushY * alpha * 0.5;\n            \n                        d.forces.push({ fx: -pushX, fy: -pushY, source: `collision with ${other.id}` });\n                    }\n                }\n            });\n        });\n    };\n}\n\n// Dragging behavior\nfunction dragStart(event, d) {\n    simulation.alphaTarget(0.3).restart();\n    d.fx = d.x;\n    d.fy = d.y;\n}\n\nfunction dragging(event, d) {\n    d.fx = event.x;\n    d.fy = event.y;\n}\n\n// function dragEnd(event, d) {\n//     d.fx = null;\n//     d.fy = null;\n//     simulation.alphaTarget(0);\n// }\nfunction dragEnd(event, d) {\n    if (!d.isFixed) { // Only release normal nodes\n        d.fx = null;\n        d.fy = null;\n        simulation.alphaTarget(0);\n    }\n}\n\nfunction toggleFixed(event, d) {\n    d.isFixed = !d.isFixed; // Toggle fixed state\n\n    if (d.isFixed) {\n        d.fx = d.x; // Lock position\n        d.fy = d.y;\n    } else {\n        d.fx = null; // Allow movement\n        d.fy = null;\n    }\n\n    d3.select(this).select(\"circle\")\n        .transition().duration(200)\n        .attr(\"stroke\", d.isFixed ? \"black\" : \"none\") // Visual cue: Black stroke if fixed\n        .attr(\"stroke-width\", d.isFixed ? 3 : 0);\n\n    simulation.alpha(0.5).restart(); // Restart simulation for immediate effect // 0.5 instead of 1 for a Less aggressive restart\n}\n\nfunction forceCustomCollision(alpha) {\n    nodes.forEach((d, i) => {\n        nodes.forEach((other, j) => {\n            if (i !== j) {\n                const dx = d.x - other.x;\n                const dy = d.y - other.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const minDist = d.radius + other.radius + collisionMargin;\n\n                if (distance < minDist && distance > 0) {\n                    const overlapRatio = 1 - distance / minDist;\n                    const force = (overlapRatio ** 2) * alpha * 5;\n\n                    // Normalize direction\n                    const pushX = (dx / distance) * force;\n                    const pushY = (dy / distance) * force;\n\n                    // Determine how to distribute the force\n                    if (!d.isFixed && !other.isFixed) {\n                        // // Both nodes are movable → Split force evenly\n                        // d.vx += pushX * 0.5;\n                        // d.vy += pushY * 0.5;\n                        // other.vx -= pushX * 0.5;\n                        // other.vy -= pushY * 0.5;\n                        const weight1 = d.significance || 1; // Default 1 if not defined\n                        const weight2 = other.significance || 1;\n                        const totalWeight = weight1 + weight2;\n                        console.log(d.significance + ' vs. ' + other.significance);\n                        \n                        const dWeight = weight2 / totalWeight;\n                        const otherWeight = weight1 / totalWeight;\n\n                        d.vx += pushX * dWeight;\n                        d.vy += pushY * dWeight;\n                        other.vx -= pushX * otherWeight;\n                        other.vy -= pushY * otherWeight;\n                    } else if (!d.isFixed) {\n                        // `d` is movable, `other` is fixed → `d` takes full force\n                        d.vx += pushX;\n                        d.vy += pushY;\n                    } else if (!other.isFixed) {\n                        // `other` is movable, `d` is fixed → `other` takes full force\n                        other.vx -= pushX;\n                        other.vy -= pushY;\n                    }\n                }\n            }\n        });\n    });\n}\n"],"names":[],"version":3,"file":"index.672d4772.js.map","sourceRoot":"/__parcel_source_root/"}